!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t() : typeof define === 'function' && define.amd ? define(t) : t(); }(0, () => {
  function e(e) { const t = this.constructor; return this.then((n) => t.resolve(e()).then(() => n), (n) => t.resolve(e()).then(() => t.reject(n))); } function t(e) { return new this((t, n) => { function o(e, n) { if (n && (typeof n === 'object' || typeof n === 'function')) { const f = n.then; if (typeof f === 'function') return void f.call(n, (t) => { o(e, t); }, (n) => { r[e] = { status: 'rejected', reason: n }, --i == 0 && t(r); }); }r[e] = { status: 'fulfilled', value: n }, --i == 0 && t(r); } if (!e || typeof e.length === 'undefined') return n(new TypeError(`${typeof e} ${e} is not iterable(cannot read property Symbol(Symbol.iterator))`)); var r = Array.prototype.slice.call(e); if (r.length === 0) return t([]); for (var i = r.length, f = 0; r.length > f; f++)o(f, r[f]); }); } function n(e) { return !(!e || typeof e.length === 'undefined'); } function o() {} function r(e) { if (!(this instanceof r)) throw new TypeError('Promises must be constructed via new'); if (typeof e !== 'function') throw new TypeError('not a function'); this._state = 0, this._handled = !1, this._value = undefined, this._deferreds = [], l(e, this); } function i(e, t) { for (;e._state === 3;)e = e._value; e._state !== 0 ? (e._handled = !0, r._immediateFn(() => { const n = e._state === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { let o; try { o = n(e._value); } catch (r) { return void u(t.promise, r); }f(t.promise, o); } else (e._state === 1 ? f : u)(t.promise, e._value); })) : e._deferreds.push(t); } function f(e, t) { try { if (t === e) throw new TypeError('A promise cannot be resolved with itself.'); if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (t instanceof r) return e._state = 3, e._value = t, void c(e); if (typeof n === 'function') return void l((function (e, t) { return function () { e.apply(t, arguments); }; }(n, t)), e); }e._state = 1, e._value = t, c(e); } catch (o) { u(e, o); } } function u(e, t) { e._state = 2, e._value = t, c(e); } function c(e) { e._state === 2 && e._deferreds.length === 0 && r._immediateFn(() => { e._handled || r._unhandledRejectionFn(e._value); }); for (let t = 0, n = e._deferreds.length; n > t; t++)i(e, e._deferreds[t]); e._deferreds = null; } function l(e, t) { let n = !1; try { e((e) => { n || (n = !0, f(t, e)); }, (e) => { n || (n = !0, u(t, e)); }); } catch (o) { if (n) return; n = !0, u(t, o); } } const a = setTimeout; r.prototype.catch = function (e) { return this.then(null, e); }, r.prototype.then = function (e, t) { const n = new this.constructor(o); return i(this, new function (e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n; }(e, t, n)), n; }, r.prototype.finally = e, r.all = function (e) { return new r((t, o) => { function r(e, n) { try { if (n && (typeof n === 'object' || typeof n === 'function')) { const u = n.then; if (typeof u === 'function') return void u.call(n, (t) => { r(e, t); }, o); }i[e] = n, --f == 0 && t(i); } catch (c) { o(c); } } if (!n(e)) return o(new TypeError('Promise.all accepts an array')); var i = Array.prototype.slice.call(e); if (i.length === 0) return t([]); for (var f = i.length, u = 0; i.length > u; u++)r(u, i[u]); }); }, r.allSettled = t, r.resolve = function (e) { return e && typeof e === 'object' && e.constructor === r ? e : new r((t) => { t(e); }); }, r.reject = function (e) { return new r((t, n) => { n(e); }); }, r.race = function (e) { return new r((t, o) => { if (!n(e)) return o(new TypeError('Promise.race accepts an array')); for (let i = 0, f = e.length; f > i; i++)r.resolve(e[i]).then(t, o); }); }, r._immediateFn = typeof setImmediate === 'function' && function (e) { setImmediate(e); } || function (e) { a(e, 0); }, r._unhandledRejectionFn = function (e) { void 0 !== console && console && console.warn('Possible Unhandled Promise Rejection:', e); }; const s = (function () { if (typeof self !== 'undefined') return self; if (typeof window !== 'undefined') return window; if (typeof global !== 'undefined') return global; throw Error('unable to locate global object'); }()); typeof s.Promise !== 'function' ? s.Promise = r : (s.Promise.prototype.finally || (s.Promise.prototype.finally = e), s.Promise.allSettled || (s.Promise.allSettled = t));
}));
